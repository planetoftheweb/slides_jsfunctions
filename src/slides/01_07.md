
<!-- .slide: data-state="layout-title" class="bg-dark"-->

# Methods

<div class="slide-link"><a href="https://go.raybo.org/9Xxu"><i class="fab fa-slideshare"></i> go.raybo.org/9Xxu</a></div>

> >

Sometimes things that seem insignificant can be quite powerful...case in point, I bring you the return statement.

---
# Return

```js [3]
function add(a, b) {
  return a+b
}
console.log(add(2,2)) //4
```

> >


Whenever you invoke a function, it's a bit like generating an equation. And equations have results. So, the basic job of the return statement is to return the result of the execution of the function.

---
# Expressions

```js [2,3|5]
function add(a, b) {
  return console.log('Success'),
    a+b
}
console.log(add(2,2))// Success
// 4
```

> >


Expressions in JavaScript are pretty important. They're valid units of code that resolve to a value. 

Here, we're using a comma to output a Success statement and then a return the value of a+b. The comma operator is interesting in that it will evaluate each of the operands and then return the value of the last operand.

So I'm just basically returning the value of the addition.

---
# Return Quirks

```js [3-4]
function add(a, b) {
  return
    console.log('Success'),
    a+b
}
console.log(add(2,2))// Success
// 4
```

> >

Let's say, I want to use the same code as before, but I want to make it look nicer so I add a carriage return.

Another quirk of javascript is that it assumes that every line of code is a statement. The compiler will add a semicolon at the end of a line if it's not there

So, when the compiler re-writes this, there will be a semicolon at the end of the return statement.

One of the by-products of the return statement is that it also stops the execution of the rest of the function, so the lines won't execute.

---
# Return Quirks

```js [3-6]
function add(a, b) {
  return (
    console.log('Success'),
    a+b
  )
}
console.log(add(2,2))// Success
// 4
```

> >

To fix something like this, you'll often see a set of parenthesis added to return statements to prevent auto semicolon insertion from causing a problem.

---
# Multiple Returns
```js [3-6]
function add(a, b) {
 if (a>b) { return a+b }
 else { return a-b }
}
console.log(add(2,3))// -1
console.log(add(3,2))// 5
```

> >

You can have more than one return statement in a function so in this conditional statement, the operation will depend on the value of a and b.

The function will return -1 and then 5.

---
# Multiple Returns
```js [1,4]
function add(a, b) {
  console.log(a + b)
}
console.log(add(2,3))
// 5
// undefined
```

> >

If you don't use a return statement, the function still returns something...in this case a value of undefined.

Since we're putting the function in a console.log statement, that statement would output undefined.


---
# Returning Functions
```js [1,4]
function counter() {
  let number = 1
  return function() { console.log(number++) }
}
let steps = counter();
steps() // 1
steps() // 2
```

<a href="https://github.dev/LinkedInLearning/javascript-functions-2502735/tree/01_07b" target="_blank"><code class="code-royal">Try it</code></a>

> >

This might sound weird, but since functions return a value, they can return other functions. This is somewhat common and useful for a number of patterns.

For example here, I'm creating a function that keeps track of a number. Each time I call this function, it's going to add one to the current count.

This sort of looks weird, but somethign really cool is happening that I hope you can see.

We initialize the steps variable so that it can basically act as the function.

When it first executes, it initializes the number to 1 and then the return function logs the number to the console.

The interesting bit is the ++ operator. That increases the value of a variable by one...and this is key AFTER whatever is happening.

When it executes again, you might think that the value of number gets reset to 1, but that's not the case.

The function being returned actually changes the value of number, so the second time it runs, the copy that's in the steps variable has a value of 2, so it outputs that.

Every time you call it the value of the number will increase.

The ability of a function inside a function to affect the value of a parent like this is called a closure and it's an extremely powerful programming pattern.